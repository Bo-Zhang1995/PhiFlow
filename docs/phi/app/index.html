<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>phi.app API documentation</title>
<meta name="description" content="Interactive application development and web interface …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.app</code></h1>
</header>
<section id="section-intro">
<p>Interactive application development and web interface.</p>
<p>See the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Interactive application development and web interface.

See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html
&#34;&#34;&#34;
from ._value import EditableValue, EditableFloat, EditableInt, EditableBool, EditableString
from ._app import App
from ._module_app import ModuleViewer
from ._display import show
from ._scene import Scene

__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.app.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>app: phi.app._app.App = None, autorun=False, gui: phi.app._display.AppDisplay = None, **config)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch the registered user interface (web interface by default).</p>
<p>This method may block until the GUI is closed.</p>
<p>This method prepares the app before showing it. No more fields should be added to the app after this method is invoked.</p>
<p>Also see the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>autorun</code></strong></dt>
<dd>If true, invokes <code><a title="phi.app.App.play" href="#phi.app.App.play">App.play()</a></code>. The default value is False unless "autorun" is passed as a command line argument.</dd>
<dt><strong><code>app</code></strong></dt>
<dd>optional) the application to display. If unspecified, searches the calling script for a subclass of App and instantiates it.</dd>
<dt><strong><code>gui</code></strong></dt>
<dd>(optional) class of GUI to use</dd>
<dt><strong><code>config</code></strong></dt>
<dd>additional GUI configuration parameters.</dd>
</dl>
<p>For a full list of parameters, see <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a>
app: App or None:
(Default value = None)
**config: </p>
<h2 id="returns">Returns</h2>
<p>reference to the GUI, depending on the implementation. For the web interface this may be the web server instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(app: App or None = None, autorun=AUTORUN, gui: AppDisplay = None, **config):
    &#34;&#34;&#34;
    Launch the registered user interface (web interface by default).
    
    This method may block until the GUI is closed.
    
    This method prepares the app before showing it. No more fields should be added to the app after this method is invoked.
    
    Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html

    Args:
      autorun: If true, invokes `App.play()`. The default value is False unless &#34;autorun&#34; is passed as a command line argument.
      app: optional) the application to display. If unspecified, searches the calling script for a subclass of App and instantiates it.
      gui: (optional) class of GUI to use
      config: additional GUI configuration parameters.
    For a full list of parameters, see https://tum-pbs.github.io/PhiFlow/Web_Interface.html
      app: App or None:  (Default value = None)
      **config: 

    Returns:
      reference to the GUI, depending on the implementation. For the web interface this may be the web server instance.

    &#34;&#34;&#34;
    frame_records = inspect.stack()[1]
    calling_module = inspect.getmodulename(frame_records[1])
    python_file = os.path.basename(sys.argv[0])[:-3]

    if app is None:
        fitting_models = _find_subclasses_in_module(App, calling_module, [])
        assert len(fitting_models) == 1, &#39;show() called without model but detected %d possible classes: %s&#39; % (len(fitting_models), fitting_models)
        app = fitting_models[0]

    if inspect.isclass(app) and issubclass(app, App):
        app = app()

    called_from_main = inspect.getmodule(app.__class__).__name__ == &#39;__main__&#39; or calling_module == python_file

    app.prepare()

    display = None
    gui = gui or DEFAULT_DISPLAY_CLASS
    if gui is not None:
        display = gui(app)
        display.configure(config)
        display.setup()
    # --- Autorun ---
    if autorun:
        if display is None:
            app.info(&#39;Starting execution because autorun is enabled.&#39;)
            app.play()  # asynchronous call
        else:
            display.play()
    # --- Show ---
    if display is None:
        warnings.warn(&#39;show() has no effect because no display is available. To use the web interface, run $ pip install phiflow&#39;)
        return app
    else:
        return display.show(called_from_main)  # blocking call</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.app.App"><code class="flex name class">
<span>class <span class="ident">App</span></span>
<span>(</span><span>name=None, subtitle='', fields=None, stride=None, base_dir='~/phi/data/', summary=None, custom_properties=None, target_scene=None, objects_to_save=None, framerate=None, dt=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class for defining an application that can be displayed in the user interface.</p>
<p>To display data, call App.add_field().
All fields need to be registered before the app is prepared or shown.</p>
<p>To launch the GUI, call show(app). This calls App.prepare() if the app was not prepared.</p>
<p>See the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class App(object):
    &#34;&#34;&#34;
    Main class for defining an application that can be displayed in the user interface.
    
    To display data, call App.add_field().
    All fields need to be registered before the app is prepared or shown.
    
    To launch the GUI, call show(app). This calls App.prepare() if the app was not prepared.
    
    See the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html

    Args:

    Returns:

    &#34;&#34;&#34;

    def __init__(self,
                 name=None,
                 subtitle=&#39;&#39;,
                 fields=None,
                 stride=None,
                 base_dir=&#39;~/phi/data/&#39;,
                 summary=None,
                 custom_properties=None,
                 target_scene=None,
                 objects_to_save=None,
                 framerate=None,
                 dt=1.0):
        self.start_time = time.time()
        &#34;&#34;&#34; Time of creation (`App` constructor invocation) &#34;&#34;&#34;
        self.name = name if name is not None else self.__class__.__name__
        &#34;&#34;&#34; Human-readable name. &#34;&#34;&#34;
        self.subtitle = subtitle
        &#34;&#34;&#34; Description to be displayed. &#34;&#34;&#34;
        self.summary = summary if summary else name
        &#34;&#34;&#34; The scene directory is derived from the summary. Defaults to `name`. &#34;&#34;&#34;
        if fields:
            self.fields = {name: TimeDependentField(name, generator) for (name, generator) in fields.items()}
        else:
            self.fields = {}
        self.message = None
        self.steps = 0
        &#34;&#34;&#34; Counts the number of times `step()` has been called. May be set by the user. &#34;&#34;&#34;
        self.time = 0
        &#34;&#34;&#34; Time variable for simulations. Can be set by the user. &#34;&#34;&#34;
        self._invalidation_counter = 0
        self._controls = []
        self._actions = []
        self._traits = []
        self.prepared = False
        &#34;&#34;&#34; Wheter `prepare()` has been called. &#34;&#34;&#34;
        self.current_action = None
        self._pause = False
        self.detect_fields = &#39;default&#39;  # False, True, &#39;default&#39;
        self.world = world
        self._dt = dt.initial_value if isinstance(dt, EditableValue) else dt
        if isinstance(dt, EditableValue):
            self._controls.append(Control(self, &#34;dt&#34;, dt))
        self.min_dt = self._dt
        self.dt_history = {}  # sparse representation of time when new timestep was set (for the next step)
        # Setup directory &amp; Logging
        self.objects_to_save = [self.__class__] if objects_to_save is None else list(objects_to_save)
        self.base_dir = os.path.expanduser(base_dir)
        if not target_scene:
            self.new_scene()
            self.uses_existing_scene = False
        else:
            self.scene = target_scene
            self.uses_existing_scene = True
        if not isfile(self.scene.subpath(&#39;info.log&#39;)):
            log_file = self.log_file = self.scene.subpath(&#39;info.log&#39;)
        else:
            index = 2
            while True:
                log_file = self.scene.subpath(&#39;info_%d.log&#39; % index)
                if not isfile(log_file):
                    break
                else:
                    index += 1
        # Setup logging
        logFormatter = logging.Formatter(&#39;%(message)s (%(levelname)s), %(asctime)sn\n&#39;)
        rootLogger = logging.getLogger()
        rootLogger.setLevel(logging.WARNING)
        customLogger = logging.Logger(&#39;app&#39;, logging.DEBUG)
        fileHandler = logging.FileHandler(log_file)
        fileHandler.setFormatter(logFormatter)
        customLogger.addHandler(fileHandler)
        consoleHandler = logging.StreamHandler(sys.stdout)
        consoleHandler.setFormatter(logFormatter)
        consoleHandler.setLevel(logging.INFO)
        customLogger.addHandler(consoleHandler)
        self.logger = customLogger
        # Framerate
        self.sequence_stride = stride if stride is not None else 1
        self.framerate = framerate if framerate is not None else stride
        &#34;&#34;&#34; Target frame rate in Hz. Play will not step faster than the framerate. `None` for unlimited frame rate. &#34;&#34;&#34;
        self._custom_properties = custom_properties if custom_properties else {}
        # State
        self.state = None
        self.step_function = None
        # Initial log message
        self.info(&#39;App created. Scene directory is %s&#39; % self.scene.path)

    @property
    def dt(self):
        &#34;&#34;&#34;
        Current time increment per step.
        Used for `step_function` set by `set_state()` or for `world.step()` in legacy-style simulations. &#34;&#34;&#34;
        return self._dt

    @dt.setter
    def dt(self, value):
        self._dt = value
        self.min_dt = min(self.min_dt, self.dt)
        self.dt_history[self.time] = self.dt

    def set_state(self, initial_state, step_function=None, show=(), dt=None):
        &#34;&#34;&#34;
        Specifies the current physics state of the app and optionally the solver step function.
        The current physics state of the app is stored in `app.state`.
        
        This method replaces `world.add()` calls from Φ-Flow 1.

        Args:
          initial_state: dict mapping names (str) to Fields or Tensors
          step_function: function to progress the state. Called as step_function(dt=dt, **current_state) (Default value = None)
          show: list of names to expose to the user interface (Default value = ())
          dt: optional) value of dt to be passed to step_function (Default value = None)

        Returns:

        &#34;&#34;&#34;
        self.state = initial_state
        self.step_function = step_function
        if dt is not None:
            self.dt = dt
        if show:
            if not self.prepared:
                for field_name in show:
                    self.add_field(field_name, lambda n=field_name: self.state[n])
                else:
                    warnings.warn(&#39;Ignoring show argument because App is already prepared.&#39;)

    @property
    def frame(self):
        &#34;&#34;&#34; Alias for `steps`. &#34;&#34;&#34;
        return self.steps

    def new_scene(self, count=None):
        if count is None:
            count = 1 if self.world.batch_size is None else self.world.batch_size
        self.scene = Scene.create(self.base_dir, self.scene_summary(), count=count, mkdir=True)

    @property
    def directory(self):
        &#34;&#34;&#34; This directory is automatically created upon `App` creation. Equal to `scene.path`. &#34;&#34;&#34;
        return self.scene.path

    def _progress(self):
        # actual method called to step.
        self.step()
        self.steps += 1
        self.invalidate()

    def invalidate(self):
        &#34;&#34;&#34; Causes the user interface to update. &#34;&#34;&#34;
        self._invalidation_counter += 1

    def step(self):
        &#34;&#34;&#34;
        Performs a single step.
        You may override this method to specify what happens when the user presses the buttons `Step` or `Play`.
        
        If a step function has been passed to `App.set_state()`, the state is progressed using that function.
        
        Otherwise, `world.step()` is executed (for phiflow 1 style simulations).
        
        App.steps automatically counts how many steps have been completed.
        If this method is not overridden, `App.time` is additionally increased by `App.dt`.

        Args:

        Returns:

        &#34;&#34;&#34;
        dt = self.dt  # prevent race conditions
        if self.step_function is None:
            world.step(dt=dt)
        else:
            new_state = self.step_function(dt=dt, **self.state)
            assert isinstance(self.state, dict), &#39;step_function must return a dict&#39;
            assert new_state.keys() == self.state.keys(), &#39;step_function must return a state with the same names as the input state.\nInput: %s\nOutput: %s&#39; % (self.state.keys(), new_state.keys())
            self.state = new_state
        self.time += dt

    @property
    def fieldnames(self):
        &#34;&#34;&#34; Alphabetical list of field names. See `get_field()`. &#34;&#34;&#34;
        return sorted(self.fields.keys())

    def get_field(self, fieldname):
        &#34;&#34;&#34;
        Reads the current value of a field.
        Fields can be added using `add_field()`.

        If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.
        &#34;&#34;&#34;
        if fieldname not in self.fields:
            raise KeyError(&#39;Field %s not declared. Available fields are %s&#39; % (fieldname, self.fields.keys()))
        return self.fields[fieldname].get(self._invalidation_counter)

    def add_field(self, name: str, value):
        &#34;&#34;&#34;
        Expose data to be displayed in the user interface.
        This method must be called before the user interface is launched, i.e. before `show(app)` or `app.prepare()` are invoked.
        
        `value` must be one of the following
        
        * Field
        * tensor
        * function without arguments returning one of the former. This function will be called each time the interface is updated.

        Args:
          name: unique human-readable name
          value: data to display
          name: str: 

        Returns:

        &#34;&#34;&#34;
        assert not self.prepared, &#39;Cannot add fields to a prepared model&#39;
        if isinstance(value, StateProxy):
            def current_state():
                return value.state
            generator = current_state
        elif callable(value):
            generator = value
        else:
            assert isinstance(value, (np.ndarray, Field, float, int, math.Tensor)), &#39;Unsupported type for field &#34;%s&#34;: %s&#39; % (name, type(value))

            def get_constant():
                return value
            generator = get_constant
        self.fields[name] = TimeDependentField(name, generator)

    @property
    def actions(self):
        &#34;&#34;&#34;
        List of all custom actions that can be invoked at runtime by the user.
        Actions can be registered using `add_action()` or by defining a method with prefix `action_`.
        &#34;&#34;&#34;
        return self._actions

    def add_action(self, name, methodcall):
        self._actions.append(Action(name, methodcall, name))

    def run_action(self, action):
        message_before = self.message
        action.method()
        self.invalidate()
        message_after = self.message
        if message_before == message_after:
            if self.message is None or self.message == &#39;&#39;:
                self.message = display_name(action.name)
            else:
                self.message += &#39; | &#39; + display_name(action.name)

    @property
    def traits(self):
        return self._traits

    def add_trait(self, trait):
        assert not self.prepared, &#39;Cannot add traits to a prepared model&#39;
        self._traits.append(trait)

    @property
    def controls(self):
        return self._controls

    def prepare(self):
        &#34;&#34;&#34;
        Prepares the app to be displayed in a user interface.
        
        This method can only be called once.
        If not invoked manually, it is automatically called before the user interface is launched.
        
        Preparation includes:
        
        * Detecting editable values from member variables that start with &#39;value_&#39;
        * Detecting actions from member functions that start with &#39;action_&#39;
        * Initializing the scene directory with a JSON file and copying related Python source files
        
        :return: self

        Args:

        Returns:

        &#34;&#34;&#34;
        if self.prepared:
            return
        logging.info(&#39;Gathering model data...&#39;)
        # Controls
        for name in self.__dict__:
            val = getattr(self, name)
            editable_value = None
            if isinstance(val, EditableValue):
                editable_value = val
                setattr(self, name, val.initial_value)  # Replace EditableValue with initial value
            elif name.startswith(&#39;value_&#39;):
                value_name = display_name(name[6:])
                dtype = type(val)
                if dtype == bool:
                    editable_value = EditableBool(value_name, val)
                elif isinstance(val, numbers.Integral):  # Int
                    editable_value = EditableInt(value_name, val)
                elif isinstance(val, numbers.Number):  # Float
                    editable_value = EditableFloat(value_name, val)
                elif isinstance(val, str):
                    editable_value = EditableString(value_name, val)
            if editable_value:
                self._controls.append(Control(self, name, editable_value))
        # Actions
        for method_name in dir(self):
            if method_name.startswith(&#39;action_&#39;) and callable(getattr(self, method_name)):
                self._actions.append(Action(display_name(method_name[7:]), getattr(self, method_name), method_name))
        # Default fields
        if len(self.fields) == 0:
            self._add_default_fields()
        # Scene
        self._update_scene_properties()
        source_files_to_save = set()
        for object in self.objects_to_save:
            try:
                source_files_to_save.add(inspect.getabsfile(object))
            except TypeError:
                pass
        for source_file in source_files_to_save:
            self.scene.copy_src(source_file)
        # End
        self.prepared = True
        return self

    def _add_default_fields(self):
        def add_default_field(trace):
            field = trace.value
            if isinstance(field, (CenteredGrid, StaggeredGrid)):
                def field_generator():
                    world_state = self.world.state
                    return trace.find_in(world_state)
                self.add_field(field.name[0].upper() + field.name[1:], field_generator)
            return None
        struct.map(add_default_field, self.world.state, leaf_condition=lambda x: isinstance(x, (CenteredGrid, StaggeredGrid)), trace=True, content_type=struct.INVALID)

    def add_custom_property(self, key, value):
        self._custom_properties[key] = value
        if self.prepared:
            self._update_scene_properties()

    def add_custom_properties(self, dictionary):
        self._custom_properties.update(dictionary)
        if self.prepared:
            self._update_scene_properties()

    def _update_scene_properties(self):
        if self.uses_existing_scene:
            return
        try:
            app_name = os.path.basename(inspect.getfile(self.__class__))
            app_path = inspect.getabsfile(self.__class__)
        except TypeError:
            app_name = app_path = &#39;&#39;
        properties = {
            &#39;instigator&#39;: &#39;App&#39;,
            &#39;traits&#39;: self.traits,
            &#39;app&#39;: str(app_name),
            &#39;app_path&#39;: str(app_path),
            &#39;name&#39;: self.name,
            &#39;description&#39;: self.subtitle,
            &#39;all_fields&#39;: self.fieldnames,
            &#39;actions&#39;: [action.name for action in self.actions],
            &#39;controls&#39;: [{control.name: control.value} for control in self.controls],
            &#39;summary&#39;: self.scene_summary(),
            &#39;steps&#39;: self.steps,
            &#39;time&#39;: self.time,
            &#39;world&#39;: struct.properties_dict(self.world.state)
        }
        properties.update(self.custom_properties())
        self.scene.properties = properties

    def settings_str(self):
        return &#39;&#39;.join([
            &#39; &#39; + str(control) for control in self.controls
        ])

    def custom_properties(self):
        return self._custom_properties

    def info(self, message: str):
        &#34;&#34;&#34;
        Update the status message.
        The status message is written to the console and the log file.
        Additionally, it may be displayed by the user interface.

        See `debug()`.

        Args:
            message: Message to display
        &#34;&#34;&#34;
        message = str(message)
        self.message = message
        self.logger.info(message)

    def debug(self, message):
        &#34;&#34;&#34;
        Prints a message to the log file but does not display it.

        See `info()`.

        Args:
            message: Message to log.
        &#34;&#34;&#34;
        logging.info(message)

    def scene_summary(self):
        return self.summary

    def show(self, **config):
        warnings.warn(&#34;Use show(model) instead.&#34;, DeprecationWarning, stacklevel=2)
        from ._display import show
        show(self, **config)

    @property
    def status(self):
        pausing = &#39;/Pausing&#39; if (self._pause and self.current_action) else &#39;&#39;
        action = self.current_action if self.current_action else &#39;Idle&#39;
        message = f&#39; - {self.message}&#39; if self.message else &#39;&#39;
        return f&#39;{action}{pausing} (t={self.format_time(self.time)} in {self.steps} steps){message}&#39;

    def format_time(self, time):
        commas = int(np.ceil(np.abs(np.log10(self.min_dt))))
        return (&#34;{time:,&#34; + f&#34;.{commas}f&#34; + &#34;}&#34;).format(time=time)

    def run_step(self, framerate=None):
        self.current_action = &#39;Running&#39;
        starttime = time.time()
        try:
            self._progress()
            if framerate is not None:
                duration = time.time() - starttime
                rest = 1.0 / framerate - duration
                if rest &gt; 0:
                    self.current_action = &#39;Waiting&#39;
                    time.sleep(rest)
        except Exception as e:
            self.info(&#39;Error during %s.step() \n %s: %s&#39; % (type(self).__name__, type(e).__name__, e))
            self.logger.exception(e)
        finally:
            self.current_action = None

    def play(self, max_steps=None, callback=None, framerate=None, callback_if_aborted=False):
        &#34;&#34;&#34;
        Run a number of steps.

        Args:
            max_steps: (optional) stop when this many steps have been completed (independent of the `steps` variable) or `pause()` is called.
            callback: Function to be run after all steps have been completed.
            framerate: Target frame rate in Hz.
            callback_if_aborted: Whether to invoke `callback` if `pause()` causes this method to abort prematurely.

        Returns:
            self
        &#34;&#34;&#34;
        if framerate is None:
            framerate = self.framerate

        def target():
            self._pause = False
            step_count = 0
            while not self._pause:
                self.run_step(framerate=framerate)
                step_count += 1
                if max_steps and step_count &gt;= max_steps:
                    break
            if callback is not None:
                if not self._pause or callback_if_aborted:
                    callback()

        thread = threading.Thread(target=target)
        thread.start()
        return self

    def pause(self):
        &#34;&#34;&#34; Causes the `play()` method to stop after finishing the current step. &#34;&#34;&#34;
        self._pause = True

    @property
    def running(self):
        &#34;&#34;&#34; Whether `play()` is currently executing. &#34;&#34;&#34;
        return self.current_action is not None

    def benchmark(self, sequence_count):
        self._pause = False
        step_count = 0
        starttime = time.time()
        for i in range(sequence_count):
            self.run_step(framerate=np.inf)
            step_count += 1
            if self._pause:
                break
        time_elapsed = time.time() - starttime
        return step_count, time_elapsed</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.app._module_app.ModuleViewer</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.App.actions"><code class="name">var <span class="ident">actions</span></code></dt>
<dd>
<div class="desc"><p>List of all custom actions that can be invoked at runtime by the user.
Actions can be registered using <code>add_action()</code> or by defining a method with prefix <code>action_</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def actions(self):
    &#34;&#34;&#34;
    List of all custom actions that can be invoked at runtime by the user.
    Actions can be registered using `add_action()` or by defining a method with prefix `action_`.
    &#34;&#34;&#34;
    return self._actions</code></pre>
</details>
</dd>
<dt id="phi.app.App.controls"><code class="name">var <span class="ident">controls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def controls(self):
    return self._controls</code></pre>
</details>
</dd>
<dt id="phi.app.App.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"><p>This directory is automatically created upon <code><a title="phi.app.App" href="#phi.app.App">App</a></code> creation. Equal to <code>scene.path</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def directory(self):
    &#34;&#34;&#34; This directory is automatically created upon `App` creation. Equal to `scene.path`. &#34;&#34;&#34;
    return self.scene.path</code></pre>
</details>
</dd>
<dt id="phi.app.App.dt"><code class="name">var <span class="ident">dt</span></code></dt>
<dd>
<div class="desc"><p>Current time increment per step.
Used for <code>step_function</code> set by <code>set_state()</code> or for <code>world.step()</code> in legacy-style simulations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dt(self):
    &#34;&#34;&#34;
    Current time increment per step.
    Used for `step_function` set by `set_state()` or for `world.step()` in legacy-style simulations. &#34;&#34;&#34;
    return self._dt</code></pre>
</details>
</dd>
<dt id="phi.app.App.fieldnames"><code class="name">var <span class="ident">fieldnames</span></code></dt>
<dd>
<div class="desc"><p>Alphabetical list of field names. See <code>get_field()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fieldnames(self):
    &#34;&#34;&#34; Alphabetical list of field names. See `get_field()`. &#34;&#34;&#34;
    return sorted(self.fields.keys())</code></pre>
</details>
</dd>
<dt id="phi.app.App.frame"><code class="name">var <span class="ident">frame</span></code></dt>
<dd>
<div class="desc"><p>Alias for <code>steps</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self):
    &#34;&#34;&#34; Alias for `steps`. &#34;&#34;&#34;
    return self.steps</code></pre>
</details>
</dd>
<dt id="phi.app.App.framerate"><code class="name">var <span class="ident">framerate</span></code></dt>
<dd>
<div class="desc"><p>Target frame rate in Hz. Play will not step faster than the framerate. <code>None</code> for unlimited frame rate.</p></div>
</dd>
<dt id="phi.app.App.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Human-readable name.</p></div>
</dd>
<dt id="phi.app.App.prepared"><code class="name">var <span class="ident">prepared</span></code></dt>
<dd>
<div class="desc"><p>Wheter <code>prepare()</code> has been called.</p></div>
</dd>
<dt id="phi.app.App.running"><code class="name">var <span class="ident">running</span></code></dt>
<dd>
<div class="desc"><p>Whether <code>play()</code> is currently executing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def running(self):
    &#34;&#34;&#34; Whether `play()` is currently executing. &#34;&#34;&#34;
    return self.current_action is not None</code></pre>
</details>
</dd>
<dt id="phi.app.App.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<div class="desc"><p>Time of creation (<code><a title="phi.app.App" href="#phi.app.App">App</a></code> constructor invocation)</p></div>
</dd>
<dt id="phi.app.App.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self):
    pausing = &#39;/Pausing&#39; if (self._pause and self.current_action) else &#39;&#39;
    action = self.current_action if self.current_action else &#39;Idle&#39;
    message = f&#39; - {self.message}&#39; if self.message else &#39;&#39;
    return f&#39;{action}{pausing} (t={self.format_time(self.time)} in {self.steps} steps){message}&#39;</code></pre>
</details>
</dd>
<dt id="phi.app.App.steps"><code class="name">var <span class="ident">steps</span></code></dt>
<dd>
<div class="desc"><p>Counts the number of times <code>step()</code> has been called. May be set by the user.</p></div>
</dd>
<dt id="phi.app.App.subtitle"><code class="name">var <span class="ident">subtitle</span></code></dt>
<dd>
<div class="desc"><p>Description to be displayed.</p></div>
</dd>
<dt id="phi.app.App.summary"><code class="name">var <span class="ident">summary</span></code></dt>
<dd>
<div class="desc"><p>The scene directory is derived from the summary. Defaults to <code>name</code>.</p></div>
</dd>
<dt id="phi.app.App.time"><code class="name">var <span class="ident">time</span></code></dt>
<dd>
<div class="desc"><p>Time variable for simulations. Can be set by the user.</p></div>
</dd>
<dt id="phi.app.App.traits"><code class="name">var <span class="ident">traits</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def traits(self):
    return self._traits</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.app.App.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, name, methodcall)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_action(self, name, methodcall):
    self._actions.append(Action(name, methodcall, name))</code></pre>
</details>
</dd>
<dt id="phi.app.App.add_custom_properties"><code class="name flex">
<span>def <span class="ident">add_custom_properties</span></span>(<span>self, dictionary)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_properties(self, dictionary):
    self._custom_properties.update(dictionary)
    if self.prepared:
        self._update_scene_properties()</code></pre>
</details>
</dd>
<dt id="phi.app.App.add_custom_property"><code class="name flex">
<span>def <span class="ident">add_custom_property</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_custom_property(self, key, value):
    self._custom_properties[key] = value
    if self.prepared:
        self._update_scene_properties()</code></pre>
</details>
</dd>
<dt id="phi.app.App.add_field"><code class="name flex">
<span>def <span class="ident">add_field</span></span>(<span>self, name: str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Expose data to be displayed in the user interface.
This method must be called before the user interface is launched, i.e. before <code><a title="phi.app.show" href="#phi.app.show">show()</a>(app)</code> or <code>app.prepare()</code> are invoked.</p>
<p><code>value</code> must be one of the following</p>
<ul>
<li>Field</li>
<li>tensor</li>
<li>function without arguments returning one of the former. This function will be called each time the interface is updated.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>unique human-readable name</dd>
<dt><strong><code>value</code></strong></dt>
<dd>data to display</dd>
<dt><strong><code>name</code></strong></dt>
<dd>str: </dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_field(self, name: str, value):
    &#34;&#34;&#34;
    Expose data to be displayed in the user interface.
    This method must be called before the user interface is launched, i.e. before `show(app)` or `app.prepare()` are invoked.
    
    `value` must be one of the following
    
    * Field
    * tensor
    * function without arguments returning one of the former. This function will be called each time the interface is updated.

    Args:
      name: unique human-readable name
      value: data to display
      name: str: 

    Returns:

    &#34;&#34;&#34;
    assert not self.prepared, &#39;Cannot add fields to a prepared model&#39;
    if isinstance(value, StateProxy):
        def current_state():
            return value.state
        generator = current_state
    elif callable(value):
        generator = value
    else:
        assert isinstance(value, (np.ndarray, Field, float, int, math.Tensor)), &#39;Unsupported type for field &#34;%s&#34;: %s&#39; % (name, type(value))

        def get_constant():
            return value
        generator = get_constant
    self.fields[name] = TimeDependentField(name, generator)</code></pre>
</details>
</dd>
<dt id="phi.app.App.add_trait"><code class="name flex">
<span>def <span class="ident">add_trait</span></span>(<span>self, trait)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trait(self, trait):
    assert not self.prepared, &#39;Cannot add traits to a prepared model&#39;
    self._traits.append(trait)</code></pre>
</details>
</dd>
<dt id="phi.app.App.benchmark"><code class="name flex">
<span>def <span class="ident">benchmark</span></span>(<span>self, sequence_count)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def benchmark(self, sequence_count):
    self._pause = False
    step_count = 0
    starttime = time.time()
    for i in range(sequence_count):
        self.run_step(framerate=np.inf)
        step_count += 1
        if self._pause:
            break
    time_elapsed = time.time() - starttime
    return step_count, time_elapsed</code></pre>
</details>
</dd>
<dt id="phi.app.App.custom_properties"><code class="name flex">
<span>def <span class="ident">custom_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_properties(self):
    return self._custom_properties</code></pre>
</details>
</dd>
<dt id="phi.app.App.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a message to the log file but does not display it.</p>
<p>See <code>info()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>Message to log.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(self, message):
    &#34;&#34;&#34;
    Prints a message to the log file but does not display it.

    See `info()`.

    Args:
        message: Message to log.
    &#34;&#34;&#34;
    logging.info(message)</code></pre>
</details>
</dd>
<dt id="phi.app.App.format_time"><code class="name flex">
<span>def <span class="ident">format_time</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_time(self, time):
    commas = int(np.ceil(np.abs(np.log10(self.min_dt))))
    return (&#34;{time:,&#34; + f&#34;.{commas}f&#34; + &#34;}&#34;).format(time=time)</code></pre>
</details>
</dd>
<dt id="phi.app.App.get_field"><code class="name flex">
<span>def <span class="ident">get_field</span></span>(<span>self, fieldname)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the current value of a field.
Fields can be added using <code>add_field()</code>.</p>
<p>If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field(self, fieldname):
    &#34;&#34;&#34;
    Reads the current value of a field.
    Fields can be added using `add_field()`.

    If a generator function was registered as the field data, this method may invoke the function which may take some time to complete.
    &#34;&#34;&#34;
    if fieldname not in self.fields:
        raise KeyError(&#39;Field %s not declared. Available fields are %s&#39; % (fieldname, self.fields.keys()))
    return self.fields[fieldname].get(self._invalidation_counter)</code></pre>
</details>
</dd>
<dt id="phi.app.App.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the status message.
The status message is written to the console and the log file.
Additionally, it may be displayed by the user interface.</p>
<p>See <code>debug()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong></dt>
<dd>Message to display</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, message: str):
    &#34;&#34;&#34;
    Update the status message.
    The status message is written to the console and the log file.
    Additionally, it may be displayed by the user interface.

    See `debug()`.

    Args:
        message: Message to display
    &#34;&#34;&#34;
    message = str(message)
    self.message = message
    self.logger.info(message)</code></pre>
</details>
</dd>
<dt id="phi.app.App.invalidate"><code class="name flex">
<span>def <span class="ident">invalidate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Causes the user interface to update.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate(self):
    &#34;&#34;&#34; Causes the user interface to update. &#34;&#34;&#34;
    self._invalidation_counter += 1</code></pre>
</details>
</dd>
<dt id="phi.app.App.new_scene"><code class="name flex">
<span>def <span class="ident">new_scene</span></span>(<span>self, count=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_scene(self, count=None):
    if count is None:
        count = 1 if self.world.batch_size is None else self.world.batch_size
    self.scene = Scene.create(self.base_dir, self.scene_summary(), count=count, mkdir=True)</code></pre>
</details>
</dd>
<dt id="phi.app.App.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Causes the <code>play()</code> method to stop after finishing the current step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause(self):
    &#34;&#34;&#34; Causes the `play()` method to stop after finishing the current step. &#34;&#34;&#34;
    self._pause = True</code></pre>
</details>
</dd>
<dt id="phi.app.App.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, max_steps=None, callback=None, framerate=None, callback_if_aborted=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a number of steps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>max_steps</code></strong></dt>
<dd>(optional) stop when this many steps have been completed (independent of the <code>steps</code> variable) or <code>pause()</code> is called.</dd>
<dt><strong><code>callback</code></strong></dt>
<dd>Function to be run after all steps have been completed.</dd>
<dt><strong><code>framerate</code></strong></dt>
<dd>Target frame rate in Hz.</dd>
<dt><strong><code>callback_if_aborted</code></strong></dt>
<dd>Whether to invoke <code>callback</code> if <code>pause()</code> causes this method to abort prematurely.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, max_steps=None, callback=None, framerate=None, callback_if_aborted=False):
    &#34;&#34;&#34;
    Run a number of steps.

    Args:
        max_steps: (optional) stop when this many steps have been completed (independent of the `steps` variable) or `pause()` is called.
        callback: Function to be run after all steps have been completed.
        framerate: Target frame rate in Hz.
        callback_if_aborted: Whether to invoke `callback` if `pause()` causes this method to abort prematurely.

    Returns:
        self
    &#34;&#34;&#34;
    if framerate is None:
        framerate = self.framerate

    def target():
        self._pause = False
        step_count = 0
        while not self._pause:
            self.run_step(framerate=framerate)
            step_count += 1
            if max_steps and step_count &gt;= max_steps:
                break
        if callback is not None:
            if not self._pause or callback_if_aborted:
                callback()

    thread = threading.Thread(target=target)
    thread.start()
    return self</code></pre>
</details>
</dd>
<dt id="phi.app.App.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepares the app to be displayed in a user interface.</p>
<p>This method can only be called once.
If not invoked manually, it is automatically called before the user interface is launched.</p>
<p>Preparation includes:</p>
<ul>
<li>Detecting editable values from member variables that start with 'value_'</li>
<li>Detecting actions from member functions that start with 'action_'</li>
<li>Initializing the scene directory with a JSON file and copying related Python source files</li>
</ul>
<p>:return: self</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;
    Prepares the app to be displayed in a user interface.
    
    This method can only be called once.
    If not invoked manually, it is automatically called before the user interface is launched.
    
    Preparation includes:
    
    * Detecting editable values from member variables that start with &#39;value_&#39;
    * Detecting actions from member functions that start with &#39;action_&#39;
    * Initializing the scene directory with a JSON file and copying related Python source files
    
    :return: self

    Args:

    Returns:

    &#34;&#34;&#34;
    if self.prepared:
        return
    logging.info(&#39;Gathering model data...&#39;)
    # Controls
    for name in self.__dict__:
        val = getattr(self, name)
        editable_value = None
        if isinstance(val, EditableValue):
            editable_value = val
            setattr(self, name, val.initial_value)  # Replace EditableValue with initial value
        elif name.startswith(&#39;value_&#39;):
            value_name = display_name(name[6:])
            dtype = type(val)
            if dtype == bool:
                editable_value = EditableBool(value_name, val)
            elif isinstance(val, numbers.Integral):  # Int
                editable_value = EditableInt(value_name, val)
            elif isinstance(val, numbers.Number):  # Float
                editable_value = EditableFloat(value_name, val)
            elif isinstance(val, str):
                editable_value = EditableString(value_name, val)
        if editable_value:
            self._controls.append(Control(self, name, editable_value))
    # Actions
    for method_name in dir(self):
        if method_name.startswith(&#39;action_&#39;) and callable(getattr(self, method_name)):
            self._actions.append(Action(display_name(method_name[7:]), getattr(self, method_name), method_name))
    # Default fields
    if len(self.fields) == 0:
        self._add_default_fields()
    # Scene
    self._update_scene_properties()
    source_files_to_save = set()
    for object in self.objects_to_save:
        try:
            source_files_to_save.add(inspect.getabsfile(object))
        except TypeError:
            pass
    for source_file in source_files_to_save:
        self.scene.copy_src(source_file)
    # End
    self.prepared = True
    return self</code></pre>
</details>
</dd>
<dt id="phi.app.App.run_action"><code class="name flex">
<span>def <span class="ident">run_action</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_action(self, action):
    message_before = self.message
    action.method()
    self.invalidate()
    message_after = self.message
    if message_before == message_after:
        if self.message is None or self.message == &#39;&#39;:
            self.message = display_name(action.name)
        else:
            self.message += &#39; | &#39; + display_name(action.name)</code></pre>
</details>
</dd>
<dt id="phi.app.App.run_step"><code class="name flex">
<span>def <span class="ident">run_step</span></span>(<span>self, framerate=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_step(self, framerate=None):
    self.current_action = &#39;Running&#39;
    starttime = time.time()
    try:
        self._progress()
        if framerate is not None:
            duration = time.time() - starttime
            rest = 1.0 / framerate - duration
            if rest &gt; 0:
                self.current_action = &#39;Waiting&#39;
                time.sleep(rest)
    except Exception as e:
        self.info(&#39;Error during %s.step() \n %s: %s&#39; % (type(self).__name__, type(e).__name__, e))
        self.logger.exception(e)
    finally:
        self.current_action = None</code></pre>
</details>
</dd>
<dt id="phi.app.App.scene_summary"><code class="name flex">
<span>def <span class="ident">scene_summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scene_summary(self):
    return self.summary</code></pre>
</details>
</dd>
<dt id="phi.app.App.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, initial_state, step_function=None, show=(), dt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Specifies the current physics state of the app and optionally the solver step function.
The current physics state of the app is stored in <code>app.state</code>.</p>
<p>This method replaces <code>world.add()</code> calls from Φ-Flow 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_state</code></strong></dt>
<dd>dict mapping names (str) to Fields or Tensors</dd>
<dt><strong><code>step_function</code></strong></dt>
<dd>function to progress the state. Called as step_function(dt=dt, **current_state) (Default value = None)</dd>
<dt><strong><code>show</code></strong></dt>
<dd>list of names to expose to the user interface (Default value = ())</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>optional) value of dt to be passed to step_function (Default value = None)</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, initial_state, step_function=None, show=(), dt=None):
    &#34;&#34;&#34;
    Specifies the current physics state of the app and optionally the solver step function.
    The current physics state of the app is stored in `app.state`.
    
    This method replaces `world.add()` calls from Φ-Flow 1.

    Args:
      initial_state: dict mapping names (str) to Fields or Tensors
      step_function: function to progress the state. Called as step_function(dt=dt, **current_state) (Default value = None)
      show: list of names to expose to the user interface (Default value = ())
      dt: optional) value of dt to be passed to step_function (Default value = None)

    Returns:

    &#34;&#34;&#34;
    self.state = initial_state
    self.step_function = step_function
    if dt is not None:
        self.dt = dt
    if show:
        if not self.prepared:
            for field_name in show:
                self.add_field(field_name, lambda n=field_name: self.state[n])
            else:
                warnings.warn(&#39;Ignoring show argument because App is already prepared.&#39;)</code></pre>
</details>
</dd>
<dt id="phi.app.App.settings_str"><code class="name flex">
<span>def <span class="ident">settings_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def settings_str(self):
    return &#39;&#39;.join([
        &#39; &#39; + str(control) for control in self.controls
    ])</code></pre>
</details>
</dd>
<dt id="phi.app.App.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, **config)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, **config):
    warnings.warn(&#34;Use show(model) instead.&#34;, DeprecationWarning, stacklevel=2)
    from ._display import show
    show(self, **config)</code></pre>
</details>
</dd>
<dt id="phi.app.App.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a single step.
You may override this method to specify what happens when the user presses the buttons <code>Step</code> or <code>Play</code>.</p>
<p>If a step function has been passed to <code><a title="phi.app.App.set_state" href="#phi.app.App.set_state">App.set_state()</a></code>, the state is progressed using that function.</p>
<p>Otherwise, <code>world.step()</code> is executed (for phiflow 1 style simulations).</p>
<p>App.steps automatically counts how many steps have been completed.
If this method is not overridden, <code><a title="phi.app.App.time" href="#phi.app.App.time">App.time</a></code> is additionally increased by <code><a title="phi.app.App.dt" href="#phi.app.App.dt">App.dt</a></code>.</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self):
    &#34;&#34;&#34;
    Performs a single step.
    You may override this method to specify what happens when the user presses the buttons `Step` or `Play`.
    
    If a step function has been passed to `App.set_state()`, the state is progressed using that function.
    
    Otherwise, `world.step()` is executed (for phiflow 1 style simulations).
    
    App.steps automatically counts how many steps have been completed.
    If this method is not overridden, `App.time` is additionally increased by `App.dt`.

    Args:

    Returns:

    &#34;&#34;&#34;
    dt = self.dt  # prevent race conditions
    if self.step_function is None:
        world.step(dt=dt)
    else:
        new_state = self.step_function(dt=dt, **self.state)
        assert isinstance(self.state, dict), &#39;step_function must return a dict&#39;
        assert new_state.keys() == self.state.keys(), &#39;step_function must return a state with the same names as the input state.\nInput: %s\nOutput: %s&#39; % (self.state.keys(), new_state.keys())
        self.state = new_state
    self.time += dt</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableBool"><code class="flex name class">
<span>class <span class="ident">EditableBool</span></span>
<span>(</span><span>name, initial_value, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableBool(EditableValue):

    def __init__(self, name, initial_value, category=None):
        EditableValue.__init__(self, name, &#39;bool&#39;, initial_value, category, (False, True), True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
</dd>
<dt id="phi.app.EditableFloat"><code class="flex name class">
<span>class <span class="ident">EditableFloat</span></span>
<span>(</span><span>name, initial_value, minmax=None, category=None, log_scale=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableFloat(EditableValue):

    def __init__(self, name, initial_value, minmax=None, category=None, log_scale=None):
        if minmax is not None:
            assert len(minmax) == 2, &#39;minmax must be pair (min, max)&#39;

        if log_scale is None:
            if minmax is None:
                log_scale = True
            else:
                log_scale = minmax[1] / float(minmax[0]) &gt; 10

        if not minmax:
            if log_scale:
                magn = log10(initial_value)
                minmax = (10.0**(magn - 3.2), 10.0**(magn + 2.2))
            else:
                if initial_value == 0.0:
                    minmax = (-10.0, 10.0)
                elif initial_value &gt; 0:
                    minmax = (0., 4. * initial_value)
                else:
                    minmax = (2. * initial_value, -2. * initial_value)
        else:
            minmax = (float(minmax[0]), float(minmax[1]))
        EditableValue.__init__(self, name, &#39;float&#39;, initial_value, category, minmax, not log_scale)

    @property
    def use_log_scale(self):
        return not self.is_linear</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableFloat.use_log_scale"><code class="name">var <span class="ident">use_log_scale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def use_log_scale(self):
    return not self.is_linear</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableInt"><code class="flex name class">
<span>class <span class="ident">EditableInt</span></span>
<span>(</span><span>name, initial_value, minmax=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableInt(EditableValue):

    def __init__(self, name, initial_value, minmax=None, category=None):
        if not minmax:
            if initial_value == 0:
                minmax = (-10, 10)
            elif initial_value &gt; 0:
                minmax = (0, 4 * initial_value)
            else:
                minmax = (2 * initial_value, -2 * initial_value)
        EditableValue.__init__(self, name, &#39;int&#39;, initial_value, category, minmax, True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
</dd>
<dt id="phi.app.EditableString"><code class="flex name class">
<span>class <span class="ident">EditableString</span></span>
<span>(</span><span>name, initial_value, category=None, rows=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableString(EditableValue):

    def __init__(self, name, initial_value, category=None, rows=20):
        EditableValue.__init__(self, name, &#39;text&#39;, initial_value, category, (&#39;&#39;, &#39;A&#39; * rows), True)

    @property
    def rows(self):
        return len(self.max_value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._value.EditableValue</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableString.rows"><code class="name">var <span class="ident">rows</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rows(self):
    return len(self.max_value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.EditableValue"><code class="flex name class">
<span>class <span class="ident">EditableValue</span></span>
<span>(</span><span>name: str, type: str, initial_value, category: str, minmax, is_linear)</span>
</code></dt>
<dd>
<div class="desc"><p>Editable values are used to specify controls of an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> that can be manipulated at runtime by the user.
EditableValues only specify the initial value of the control.
During <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code>, they are replaced by <code>Control</code> objects that hold the actual value.</p>
<p>This constructor should not be used directly. Instantiate a subclass instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Human-readable name to be displayed.</dd>
<dt><strong><code>type</code></strong></dt>
<dd>Type identifier</dd>
<dt>initial_value:</dt>
<dt><strong><code>category</code></strong></dt>
<dd>Used to sort values. Not currently used.</dd>
<dt><strong><code>minmax</code></strong></dt>
<dd>tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.</dd>
<dt><strong><code>is_linear</code></strong></dt>
<dd>Whether to use a linear slider where applicable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditableValue(object):
    &#34;&#34;&#34;
    Editable values are used to specify controls of an `App` that can be manipulated at runtime by the user.
    EditableValues only specify the initial value of the control.
    During `App.prepare()`, they are replaced by `Control` objects that hold the actual value.
    &#34;&#34;&#34;

    def __init__(self, name: str, type: str, initial_value, category: str, minmax, is_linear):
        &#34;&#34;&#34;
        This constructor should not be used directly. Instantiate a subclass instead.

        Args:
            name: Human-readable name to be displayed.
            type: Type identifier
            initial_value:
            category: Used to sort values. Not currently used.
            minmax: tuple (min, max). Determines the range of allowed values. Determines the maximum expected text length for text fields.
            is_linear: Whether to use a linear slider where applicable.
        &#34;&#34;&#34;
        self.name = name
        &#34;&#34;&#34; Human-readable name to be displayed. &#34;&#34;&#34;
        self.type = type
        &#34;&#34;&#34; Type identifier: &#39;int&#39;, &#39;float&#39;, &#39;bool&#39;, &#39;text&#39;. &#34;&#34;&#34;
        self.initial_value = initial_value
        &#34;&#34;&#34; Set manually or value of the variable when `App.prepare()` was called. &#34;&#34;&#34;
        self.category = category
        &#34;&#34;&#34; Used to sort values. Not currently used. &#34;&#34;&#34;
        self.minmax = minmax
        self.is_linear = is_linear
        &#34;&#34;&#34; Whether to use a linear slider where applicable. &#34;&#34;&#34;

    @property
    def min_value(self):
        &#34;&#34;&#34; Determines the range of allowed values. &#34;&#34;&#34;
        return self.minmax[0]

    @property
    def max_value(self):
        &#34;&#34;&#34; Determines the range of allowed values. Determines the maximum expected text length for text fields. &#34;&#34;&#34;
        return self.minmax[1]

    @staticmethod
    def value(value_or_editable_value):
        &#34;&#34;&#34;
        Retrieves the initial value if the argument is an `EditableValue`, else returns the given value.
        This is useful for consistently accessing an `App` variable before and after `prepare()` is called.
        &#34;&#34;&#34;
        if isinstance(value_or_editable_value, EditableValue):
            return value_or_editable_value.initial_value
        else:
            return value_or_editable_value</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.app._value.EditableBool</li>
<li>phi.app._value.EditableFloat</li>
<li>phi.app._value.EditableInt</li>
<li>phi.app._value.EditableString</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="phi.app.EditableValue.value"><code class="name flex">
<span>def <span class="ident">value</span></span>(<span>value_or_editable_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the initial value if the argument is an <code><a title="phi.app.EditableValue" href="#phi.app.EditableValue">EditableValue</a></code>, else returns the given value.
This is useful for consistently accessing an <code><a title="phi.app.App" href="#phi.app.App">App</a></code> variable before and after <code>prepare()</code> is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def value(value_or_editable_value):
    &#34;&#34;&#34;
    Retrieves the initial value if the argument is an `EditableValue`, else returns the given value.
    This is useful for consistently accessing an `App` variable before and after `prepare()` is called.
    &#34;&#34;&#34;
    if isinstance(value_or_editable_value, EditableValue):
        return value_or_editable_value.initial_value
    else:
        return value_or_editable_value</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.EditableValue.category"><code class="name">var <span class="ident">category</span></code></dt>
<dd>
<div class="desc"><p>Used to sort values. Not currently used.</p></div>
</dd>
<dt id="phi.app.EditableValue.initial_value"><code class="name">var <span class="ident">initial_value</span></code></dt>
<dd>
<div class="desc"><p>Set manually or value of the variable when <code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">App.prepare()</a></code> was called.</p></div>
</dd>
<dt id="phi.app.EditableValue.is_linear"><code class="name">var <span class="ident">is_linear</span></code></dt>
<dd>
<div class="desc"><p>Whether to use a linear slider where applicable.</p></div>
</dd>
<dt id="phi.app.EditableValue.max_value"><code class="name">var <span class="ident">max_value</span></code></dt>
<dd>
<div class="desc"><p>Determines the range of allowed values. Determines the maximum expected text length for text fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_value(self):
    &#34;&#34;&#34; Determines the range of allowed values. Determines the maximum expected text length for text fields. &#34;&#34;&#34;
    return self.minmax[1]</code></pre>
</details>
</dd>
<dt id="phi.app.EditableValue.min_value"><code class="name">var <span class="ident">min_value</span></code></dt>
<dd>
<div class="desc"><p>Determines the range of allowed values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_value(self):
    &#34;&#34;&#34; Determines the range of allowed values. &#34;&#34;&#34;
    return self.minmax[0]</code></pre>
</details>
</dd>
<dt id="phi.app.EditableValue.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Human-readable name to be displayed.</p></div>
</dd>
<dt id="phi.app.EditableValue.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Type identifier: 'int', 'float', 'bool', 'text'.</p></div>
</dd>
</dl>
</dd>
<dt id="phi.app.ModuleViewer"><code class="flex name class">
<span>class <span class="ident">ModuleViewer</span></span>
<span>(</span><span>fields=None, stride=None, base_dir='~/phi/data/', summary=None, custom_properties=None, target_scene=None, objects_to_save=None, framerate=None, dt=1.0, **show_config)</span>
</code></dt>
<dd>
<div class="desc"><p>ModuleViewer launches the user interface to display the contents of the calling Python script.</p>
<p>Name and subtitle of the App may be specified in the module docstring (string before imports).
The first line is interpreted as the name, the rest as the subtitle.
If not specified, a generic name and description is chosen.</p>
<p>Use ModuleViewer.range() as a for-loop iteratable to control the loop execution from within the GUI.</p>
<p>Also see the user interface documentation at <a href="https://tum-pbs.github.io/PhiFlow/Web_Interface.html">https://tum-pbs.github.io/PhiFlow/Web_Interface.html</a></p>
<p>Creates the ModuleViewer <code><a title="phi.app.App" href="#phi.app.App">App</a></code> and <code><a title="phi.app.show" href="#phi.app.show">show()</a></code>s it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fields</code></strong></dt>
<dd>(Optional) names of global variables to be displayed.
If not provided, searches all global variables for Field or Tensor values.
All fields must exist as global variables before the ModuleViewer is instantiated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModuleViewer(App):
    &#34;&#34;&#34;
    ModuleViewer launches the user interface to display the contents of the calling Python script.

    Name and subtitle of the App may be specified in the module docstring (string before imports).
    The first line is interpreted as the name, the rest as the subtitle.
    If not specified, a generic name and description is chosen.

    Use ModuleViewer.range() as a for-loop iteratable to control the loop execution from within the GUI.

    Also see the user interface documentation at https://tum-pbs.github.io/PhiFlow/Web_Interface.html
    &#34;&#34;&#34;
    def __init__(self,
                 fields=None,
                 stride=None,
                 base_dir=&#39;~/phi/data/&#39;,
                 summary=None,
                 custom_properties=None,
                 target_scene=None,
                 objects_to_save=None,
                 framerate=None,
                 dt=1.0,
                 **show_config):
        &#34;&#34;&#34;
        Creates the ModuleViewer `App` and `show()`s it.

        Args:
            fields: (Optional) names of global variables to be displayed.
                If not provided, searches all global variables for Field or Tensor values.
                All fields must exist as global variables before the ModuleViewer is instantiated.
        &#34;&#34;&#34;
        module = inspect.getmodule(inspect.stack()[1].frame)
        doc = module.__doc__
        if doc is None:
            name = os.path.basename(module.__file__)[:-3]
            subtitle = module.__doc__ or module.__file__
        else:
            end_of_line = doc.index(&#39;\n&#39;)
            name = doc[:end_of_line].strip()
            subtitle = doc[end_of_line:].strip() or None
        App.__init__(self, name, subtitle, fields=None, stride=stride, base_dir=base_dir, summary=summary, custom_properties=custom_properties, target_scene=target_scene, objects_to_save=objects_to_save, framerate=framerate, dt=dt)
        if fields is None:
            for name in dir(module):
                val = getattr(module, name)
                if isinstance(val, Field) or (isinstance(val, Tensor) and val.shape.spatial_rank &gt; 0):
                    self.add_field(name, lambda name=name: getattr(module, name))
        else:
            for name in fields:
                self.add_field(name, lambda name=name: getattr(module, name))
        self.step_exec_event = Event()
        self.step_finished_event = Event()
        Thread(target=lambda: show(self, **show_config)).start()

    def range(self, *args):
        &#34;&#34;&#34;
        Similar to `range()`, returns a generator that can be used in a `for` loop.

            for step in ModuleViewer().range(100):
                print(f&#39;Running step {step}&#39;)

        However, `ModuleViewer.range()` controlling the flow via the user interface.
        Each element returned by the generator waits for `ModuleViewer.step()` to be invoked once.

        Note that `step` is always equal to `ModuleViewer.step`.

        This method can be invoked multiple times.
        However, do not call this method while one `range` is still active.

        Args:
            *args:
                No arguments for infinite loop.
                `(stop: int)` to set number of iterations.
                `(start: int, stop: int)` to additionally set initial value of `step`.

        Returns:
            generator yielding `ModuleViewer.step`
        &#34;&#34;&#34;
        if len(args) == 0:
            while True:
                self.step_exec_event.wait()
                yield self.steps
                self.step_exec_event.clear()
                self.step_finished_event.set()
        elif len(args) == 1:
            for _ in range(args[0]):
                self.step_exec_event.wait()
                yield self.steps
                self.step_exec_event.clear()
                self.step_finished_event.set()
        elif len(args) == 2:
            for i in range(args[0], args[1]):
                self.step_exec_event.wait()
                self.steps = i
                yield self.steps
                self.step_exec_event.clear()
                self.step_finished_event.set()
        else:
            raise ValueError(args)

    def step(self):
        &#34;&#34;&#34;
        Allows the generator returned by `ModuleViewer.range()` to advance one element.
        In typical scenarios, this will run one loop iteration in the top-level script.
        &#34;&#34;&#34;
        self.step_finished_event.clear()
        self.step_exec_event.set()
        self.step_finished_event.wait()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.app._app.App</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="phi.app.ModuleViewer.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code>range()</code>, returns a generator that can be used in a <code>for</code> loop.</p>
<pre><code>for step in ModuleViewer().range(100):
    print(f'Running step {step}')
</code></pre>
<p>However, <code><a title="phi.app.ModuleViewer.range" href="#phi.app.ModuleViewer.range">ModuleViewer.range()</a></code> controlling the flow via the user interface.
Each element returned by the generator waits for <code><a title="phi.app.ModuleViewer.step" href="#phi.app.ModuleViewer.step">ModuleViewer.step()</a></code> to be invoked once.</p>
<p>Note that <code>step</code> is always equal to <code><a title="phi.app.ModuleViewer.step" href="#phi.app.ModuleViewer.step">ModuleViewer.step()</a></code>.</p>
<p>This method can be invoked multiple times.
However, do not call this method while one <code>range</code> is still active.</p>
<h2 id="args">Args</h2>
<p>*args:
No arguments for infinite loop.
<code>(stop: int)</code> to set number of iterations.
<code>(start: int, stop: int)</code> to additionally set initial value of <code>step</code>.</p>
<h2 id="returns">Returns</h2>
<p>generator yielding <code><a title="phi.app.ModuleViewer.step" href="#phi.app.ModuleViewer.step">ModuleViewer.step()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range(self, *args):
    &#34;&#34;&#34;
    Similar to `range()`, returns a generator that can be used in a `for` loop.

        for step in ModuleViewer().range(100):
            print(f&#39;Running step {step}&#39;)

    However, `ModuleViewer.range()` controlling the flow via the user interface.
    Each element returned by the generator waits for `ModuleViewer.step()` to be invoked once.

    Note that `step` is always equal to `ModuleViewer.step`.

    This method can be invoked multiple times.
    However, do not call this method while one `range` is still active.

    Args:
        *args:
            No arguments for infinite loop.
            `(stop: int)` to set number of iterations.
            `(start: int, stop: int)` to additionally set initial value of `step`.

    Returns:
        generator yielding `ModuleViewer.step`
    &#34;&#34;&#34;
    if len(args) == 0:
        while True:
            self.step_exec_event.wait()
            yield self.steps
            self.step_exec_event.clear()
            self.step_finished_event.set()
    elif len(args) == 1:
        for _ in range(args[0]):
            self.step_exec_event.wait()
            yield self.steps
            self.step_exec_event.clear()
            self.step_finished_event.set()
    elif len(args) == 2:
        for i in range(args[0], args[1]):
            self.step_exec_event.wait()
            self.steps = i
            yield self.steps
            self.step_exec_event.clear()
            self.step_finished_event.set()
    else:
        raise ValueError(args)</code></pre>
</details>
</dd>
<dt id="phi.app.ModuleViewer.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the generator returned by <code><a title="phi.app.ModuleViewer.range" href="#phi.app.ModuleViewer.range">ModuleViewer.range()</a></code> to advance one element.
In typical scenarios, this will run one loop iteration in the top-level script.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self):
    &#34;&#34;&#34;
    Allows the generator returned by `ModuleViewer.range()` to advance one element.
    In typical scenarios, this will run one loop iteration in the top-level script.
    &#34;&#34;&#34;
    self.step_finished_event.clear()
    self.step_exec_event.set()
    self.step_finished_event.wait()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.app.Scene"><code class="flex name class">
<span>class <span class="ident">Scene</span></span>
<span>(</span><span>parent_directory: str, scene_id: int, path: str, batch_dim: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides methods for reading and writing simulation data.</p>
<p>See the format documentation at <a href="https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html">https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html</a> .</p>
<p>All data of a <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> is located inside a single directory with name <code>sim_xxxxxx</code> where <code>xxxxxx</code> is the <code>id</code>.
The data of the scene is organized into NumPy files by <em>name</em> and <em>frame</em>.</p>
<p>To create a new scene, use <code><a title="phi.app.Scene.create" href="#phi.app.Scene.create">Scene.create()</a></code>.
To reference an existing scene, use <code><a title="phi.app.Scene.at" href="#phi.app.Scene.at">Scene.at()</a></code>.
To list all scenes within a directory, use <code><a title="phi.app.Scene.list" href="#phi.app.Scene.list">Scene.list()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scene(object):
    &#34;&#34;&#34;
    Provides methods for reading and writing simulation data.

    See the format documentation at https://tum-pbs.github.io/PhiFlow/Scene_Format_Specification.html .

    All data of a `Scene` is located inside a single directory with name `sim_xxxxxx` where `xxxxxx` is the `id`.
    The data of the scene is organized into NumPy files by *name* and *frame*.

    To create a new scene, use `Scene.create()`.
    To reference an existing scene, use `Scene.at()`.
    To list all scenes within a directory, use `Scene.list()`.
    &#34;&#34;&#34;

    def __init__(self,
                 parent_directory: str,
                 scene_id: int or list,
                 path: str or list,
                 batch_dim: str or None = None):
        self.parent_directory: str = parent_directory
        &#34;&#34;&#34; Directory containing the scene directory. &#34;&#34;&#34;
        self.id = scene_id
        &#34;&#34;&#34;
        All scenes inside one directory have a unique id.
        The id of a new Scene is always 1 + previously largest id.
        
        For a single scene, `type(id) = int`, for a batch, `type(id) = tuple`.
        &#34;&#34;&#34;
        self._properties = None
        self.path = path
        &#34;&#34;&#34;
        Relative path of the scene directory.
        
        For a single scene, `type(path) = str`, for a batch, `type(path) = tuple`.
        &#34;&#34;&#34;
        if isinstance(path, str):
            self.abs_path = abspath(path)
        else:
            self.abs_path = tuple(abspath(p) for p in path)
        &#34;&#34;&#34;
        Absolute path of the scene directory.
        
        For a single scene, `type(abs_path) = str`, for a batch, `type(abs_path) = tuple`.
        &#34;&#34;&#34;
        self.batch_dim = batch_dim

    @staticmethod
    def create(parent_directory, count=1, copy_calling_script=True, batch_dim: str or None = None) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a new `Scene` or a batch of new scenes inside `parent_directory`.

        See Also:
            `Scene.at()`, `Scene.list()`.

        Args:
            parent_directory: Directory to hold the new `Scene`. If it doesn&#39;t exist, it will be created.
            count: Number of scenes to create. Multiple scenes will also also represented by a single `Scene` object.
            copy_calling_script: Whether to copy the Python file that invoked this method into the `src` folder of all created scenes.
                See `Scene.copy_calling_script()`.
            batch_dim: Dimension corresponding to batch of scenes if `count &gt; 1`.

        Returns:
            Single `Scene` object representing the new scene(s).
        &#34;&#34;&#34;
        if count &gt; 1:
            assert isinstance(batch_dim, str), &#34;batch_dim must be specified if count &gt; 1.&#34;
            scenes = [Scene.create(parent_directory, 1, copy_calling_script) for _ in range(count)]
            return Scene(parent_directory, tuple(s.id for s in scenes), tuple(s.path for s in scenes), batch_dim=batch_dim)
        else:
            parent_directory = expanduser(parent_directory)
            abs_dir = abspath(parent_directory)
            if not isdir(abs_dir):
                os.makedirs(abs_dir)
                next_id = 0
            else:
                indices = [int(name[4:]) for name in os.listdir(abs_dir) if name.startswith(&#34;sim_&#34;)]
                next_id = max([-1] + indices) + 1
            path = join(parent_directory, f&#34;sim_{next_id:06d}&#34;)
            scene = Scene(parent_directory, next_id, path)
            scene.mkdir()
            if copy_calling_script:
                try:
                    scene.copy_calling_script()
                except IOError as err:
                    warnings.warn(f&#34;Failed to copy calling script to scene during Scene.create(): {err}&#34;)
            return scene

    @staticmethod
    def list(parent_directory: str, include_other: bool = False) -&gt; tuple:
        &#34;&#34;&#34;
        Lists all scenes inside the given directory.

        See Also:
            `Scene.at()`, `Scene.create()`.

        Args:
            parent_directory: Directory that contains scene folders.
            include_other: Whether folders that do not match the scene format should also be treated as scenes.

        Returns:
            `tuple` of scenes.
        &#34;&#34;&#34;
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            return ()
        names = [sim for sim in os.listdir(abs_dir) if sim.startswith(&#34;sim_&#34;) or (include_other and isdir(join(abs_dir, sim)))]
        return tuple(Scene(parent_directory, scene_id=int(name[4:]) if name.startswith(&#34;sim_&#34;) else None, path=join(parent_directory, name))
                     for name in names)

    @staticmethod
    def at(directory, id: int or None = None) -&gt; &#39;Scene&#39;:
        &#34;&#34;&#34;
        Creates a `Scene` for an existing directory.

        See Also:
            `Scene.create()`, `Scene.list()`.

        Args:
            directory: Either directory containing scene folder if `id` is given, or scene path if `id=None`.
            id: (Optional) Scene `id`, will be determined from `directory` if not specified.

        Returns:
            `Scene` object for existing scene.
        &#34;&#34;&#34;
        directory = expanduser(directory)
        if id is not None:
            assert not basename(directory).startswith(&#39;sim_&#39;), &#34;When passing a scene directory, set id=None.&#34;
            path = join(directory, f&#34;sim_{id:06d}&#34;)
            if not isdir(path):
                raise IOError(f&#34;There is no scene at &#39;{path}&#39;&#34;)
            return Scene(directory, id, path)
        else:
            if directory[-1] == &#39;/&#39;:  # remove trailing backslash
                directory = directory[0:-1]
            if not isdir(directory):
                raise IOError(f&#34;There is no scene at &#39;{abspath(directory)}&#39;&#34;)
            scene_name = basename(directory)
            scene_id = int(scene_name[4:]) if scene_name.startswith(&#34;sim_&#34;) else None
            parent_directory = dirname(directory)
            return Scene(parent_directory, scene_id, directory)

    def subpath(self, name: str, create: bool = False) -&gt; str or tuple:
        &#34;&#34;&#34;
        Resolves the relative path `name` with this `Scene` as the root folder.

        Args:
            name: Relative path with this `Scene` as the root folder.
            create: Whether to create a directory of that name.

        Returns:
            Relative path including the path to this `Scene`.
            In batch mode, returns a `tuple`, else a `str`.
        &#34;&#34;&#34;
        if isinstance(self.path, str):
            path = join(self.path, name)
            if create and not isdir(path):
                os.mkdir(path)
            return path
        else:
            result = []
            for p in self.path:
                path = join(p, name)
                if create and not isdir(path):
                    os.mkdir(path)
                result.append(path)
            return tuple(result)

    def _init_properties(self):
        if self._properties is not None:
            return
        dfile = join(self.path, &#34;description.json&#34;)
        if isfile(dfile):
            self._properties = json.load(dfile)
        else:
            self._properties = {}

    def exists_config(self):
        &#34;&#34;&#34; Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. &#34;&#34;&#34;
        if isinstance(self.path, str):
            return isfile(join(self.path, &#34;description.json&#34;))
        else:
            return any(isfile(join(p, &#34;description.json&#34;)) for p in self.path)

    @property
    def properties(self):
        self._init_properties()
        return self._properties

    @properties.setter
    def properties(self, dict):
        self._properties = dict
        with open(join(self.path, &#34;description.json&#34;), &#34;w&#34;) as out:
            json.dump(self._properties, out, indent=2)

    def put_property(self, key, value):
        self._init_properties()
        self._properties[key] = value
        with open(join(self.path, &#34;description.json&#34;), &#34;w&#34;) as out:
            json.dump(self._properties, out, indent=2)

    # def read_sim_frames(self, fieldnames=None, frames=None):
    #     return read_sim_frames(self.path, fieldnames=fieldnames, frames=frames, batch_dim=self.batch_dim)

    def read_array(self, field_name, frame):
        return read_sim_frame(self.path, field_name, frame=frame, batch_dim=self.batch_dim)

    def write_sim_frame(self, arrays, fieldnames, frame):
        write_sim_frame(self.path, arrays, names=fieldnames, frame=frame, batch_dim=self.batch_dim)

    def write(self, data: dict, frame=0):
        &#34;&#34;&#34;
        Writes fields to this scene.
        One NumPy file will be created for each `phi.field.Field`

        See Also:
            `Scene.read()`.

        Args:
            data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.
            frame: Frame number.
        &#34;&#34;&#34;
        write_sim_frame(self.path, data, names=None, frame=frame, batch_dim=self.batch_dim)

    def read(self, names: str or tuple or list, frame=0, convert_to_backend=True):
        &#34;&#34;&#34;
        Reads one or multiple fields from disc.

        See Also:
            `Scene.write()`.

        Args:
            names: Single field name or sequence of field names.
            frame: Frame number.
            convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

        Returns:
            Single `phi.field.Field` or sequence of fields, depending on the type of `names`.
        &#34;&#34;&#34;
        return read_sim_frame(self.path, names, frame=frame, convert_to_backend=convert_to_backend, batch_dim=self.batch_dim)

    @property
    def fieldnames(self) -&gt; tuple:
        &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
        return get_fieldnames(self.path)

    @property
    def frames(self):
        &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.get_frames()`. &#34;&#34;&#34;
        return get_frames(self.path)

    def get_frames(self, mode=&#34;intersect&#34;):
        return get_frames(self.path, None, mode)

    def __str__(self):
        return self.path

    def __repr__(self):
        return self.path

    def __eq__(self, other):
        return isinstance(other, Scene) and other.path == self.path

    def copy_calling_script(self, full_trace=False, include_context_information=True):
        &#34;&#34;&#34;
        Copies the Python file that called this method into the `src` folder of this `Scene`.

        Args:
            full_trace: Whether to include scripts that indirectly called this method.
            include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.
        &#34;&#34;&#34;
        script_paths = [frame[1] for frame in inspect.stack()]
        script_paths = list(filter(lambda path: not _is_phi_file(path), script_paths))
        script_paths = set(script_paths) if full_trace else [script_paths[0]]
        for script_path in script_paths:
            shutil.copy(script_path, join(self.subpath(&#39;src&#39;, create=True), basename(script_path)))
        if include_context_information:
            with open(join(self.subpath(&#39;src&#39;, create=True), &#39;context.json&#39;), &#39;w&#39;) as context_file:
                json.dump({
                    &#39;phi_version&#39;: phi_version,
                    &#39;argv&#39;: sys.argv
                }, context_file)

    def copy_src(self, path, only_external=True):
        if not only_external or not _is_phi_file(path):
            shutil.copy(path, join(self.subpath(&#39;src&#39;, create=True), basename(path)))

    def mkdir(self, subdir=None):
        assert isinstance(self.path, str)
        isdir(self.path) or os.mkdir(self.path)
        if subdir is not None:
            subpath = join(self.path, subdir)
            isdir(subpath) or os.mkdir(subpath)

    def remove(self):
        &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
        if isinstance(self.abs_path, str):
            if isdir(self.abs_path):
                shutil.rmtree(self.abs_path)
        else:
            for p in self.abs_path:
                if isdir(p):
                    shutil.rmtree(p)

    def data_paths(self, frames, field_names):
        for frame in frames:
            yield tuple([_filename(self.path, name, frame) for name in field_names])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="phi.app.Scene.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>directory, id: int = None) ‑> phi.app._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> for an existing directory.</p>
<p>See Also:
<code><a title="phi.app.Scene.create" href="#phi.app.Scene.create">Scene.create()</a></code>, <code><a title="phi.app.Scene.list" href="#phi.app.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong></dt>
<dd>Either directory containing scene folder if <code>id</code> is given, or scene path if <code>id=None</code>.</dd>
<dt><strong><code>id</code></strong></dt>
<dd>(Optional) Scene <code>id</code>, will be determined from <code>directory</code> if not specified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> object for existing scene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def at(directory, id: int or None = None) -&gt; &#39;Scene&#39;:
    &#34;&#34;&#34;
    Creates a `Scene` for an existing directory.

    See Also:
        `Scene.create()`, `Scene.list()`.

    Args:
        directory: Either directory containing scene folder if `id` is given, or scene path if `id=None`.
        id: (Optional) Scene `id`, will be determined from `directory` if not specified.

    Returns:
        `Scene` object for existing scene.
    &#34;&#34;&#34;
    directory = expanduser(directory)
    if id is not None:
        assert not basename(directory).startswith(&#39;sim_&#39;), &#34;When passing a scene directory, set id=None.&#34;
        path = join(directory, f&#34;sim_{id:06d}&#34;)
        if not isdir(path):
            raise IOError(f&#34;There is no scene at &#39;{path}&#39;&#34;)
        return Scene(directory, id, path)
    else:
        if directory[-1] == &#39;/&#39;:  # remove trailing backslash
            directory = directory[0:-1]
        if not isdir(directory):
            raise IOError(f&#34;There is no scene at &#39;{abspath(directory)}&#39;&#34;)
        scene_name = basename(directory)
        scene_id = int(scene_name[4:]) if scene_name.startswith(&#34;sim_&#34;) else None
        parent_directory = dirname(directory)
        return Scene(parent_directory, scene_id, directory)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>parent_directory, count=1, copy_calling_script=True, batch_dim: str = None) ‑> phi.app._scene.Scene</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> or a batch of new scenes inside <code>parent_directory</code>.</p>
<p>See Also:
<code><a title="phi.app.Scene.at" href="#phi.app.Scene.at">Scene.at()</a></code>, <code><a title="phi.app.Scene.list" href="#phi.app.Scene.list">Scene.list()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory to hold the new <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code>. If it doesn't exist, it will be created.</dd>
<dt><strong><code>count</code></strong></dt>
<dd>Number of scenes to create. Multiple scenes will also also represented by a single <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> object.</dd>
<dt><strong><code>copy_calling_script</code></strong></dt>
<dd>Whether to copy the Python file that invoked this method into the <code>src</code> folder of all created scenes.
See <code><a title="phi.app.Scene.copy_calling_script" href="#phi.app.Scene.copy_calling_script">Scene.copy_calling_script()</a></code>.</dd>
<dt><strong><code>batch_dim</code></strong></dt>
<dd>Dimension corresponding to batch of scenes if <code>count &gt; 1</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> object representing the new scene(s).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(parent_directory, count=1, copy_calling_script=True, batch_dim: str or None = None) -&gt; &#39;Scene&#39;:
    &#34;&#34;&#34;
    Creates a new `Scene` or a batch of new scenes inside `parent_directory`.

    See Also:
        `Scene.at()`, `Scene.list()`.

    Args:
        parent_directory: Directory to hold the new `Scene`. If it doesn&#39;t exist, it will be created.
        count: Number of scenes to create. Multiple scenes will also also represented by a single `Scene` object.
        copy_calling_script: Whether to copy the Python file that invoked this method into the `src` folder of all created scenes.
            See `Scene.copy_calling_script()`.
        batch_dim: Dimension corresponding to batch of scenes if `count &gt; 1`.

    Returns:
        Single `Scene` object representing the new scene(s).
    &#34;&#34;&#34;
    if count &gt; 1:
        assert isinstance(batch_dim, str), &#34;batch_dim must be specified if count &gt; 1.&#34;
        scenes = [Scene.create(parent_directory, 1, copy_calling_script) for _ in range(count)]
        return Scene(parent_directory, tuple(s.id for s in scenes), tuple(s.path for s in scenes), batch_dim=batch_dim)
    else:
        parent_directory = expanduser(parent_directory)
        abs_dir = abspath(parent_directory)
        if not isdir(abs_dir):
            os.makedirs(abs_dir)
            next_id = 0
        else:
            indices = [int(name[4:]) for name in os.listdir(abs_dir) if name.startswith(&#34;sim_&#34;)]
            next_id = max([-1] + indices) + 1
        path = join(parent_directory, f&#34;sim_{next_id:06d}&#34;)
        scene = Scene(parent_directory, next_id, path)
        scene.mkdir()
        if copy_calling_script:
            try:
                scene.copy_calling_script()
            except IOError as err:
                warnings.warn(f&#34;Failed to copy calling script to scene during Scene.create(): {err}&#34;)
        return scene</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>parent_directory: str, include_other: bool = False) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all scenes inside the given directory.</p>
<p>See Also:
<code><a title="phi.app.Scene.at" href="#phi.app.Scene.at">Scene.at()</a></code>, <code><a title="phi.app.Scene.create" href="#phi.app.Scene.create">Scene.create()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_directory</code></strong></dt>
<dd>Directory that contains scene folders.</dd>
<dt><strong><code>include_other</code></strong></dt>
<dd>Whether folders that do not match the scene format should also be treated as scenes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of scenes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def list(parent_directory: str, include_other: bool = False) -&gt; tuple:
    &#34;&#34;&#34;
    Lists all scenes inside the given directory.

    See Also:
        `Scene.at()`, `Scene.create()`.

    Args:
        parent_directory: Directory that contains scene folders.
        include_other: Whether folders that do not match the scene format should also be treated as scenes.

    Returns:
        `tuple` of scenes.
    &#34;&#34;&#34;
    parent_directory = expanduser(parent_directory)
    abs_dir = abspath(parent_directory)
    if not isdir(abs_dir):
        return ()
    names = [sim for sim in os.listdir(abs_dir) if sim.startswith(&#34;sim_&#34;) or (include_other and isdir(join(abs_dir, sim)))]
    return tuple(Scene(parent_directory, scene_id=int(name[4:]) if name.startswith(&#34;sim_&#34;) else None, path=join(parent_directory, name))
                 for name in names)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="phi.app.Scene.fieldnames"><code class="name">var <span class="ident">fieldnames</span> : tuple</code></dt>
<dd>
<div class="desc"><p>Determines all field names present in this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code>, independent of frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fieldnames(self) -&gt; tuple:
    &#34;&#34;&#34; Determines all field names present in this `Scene`, independent of frame. &#34;&#34;&#34;
    return get_fieldnames(self.path)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.frames"><code class="name">var <span class="ident">frames</span></code></dt>
<dd>
<div class="desc"><p>Determines all frame numbers present in this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code>, independent of field names. See <code><a title="phi.app.Scene.get_frames" href="#phi.app.Scene.get_frames">Scene.get_frames()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self):
    &#34;&#34;&#34; Determines all frame numbers present in this `Scene`, independent of field names. See `Scene.get_frames()`. &#34;&#34;&#34;
    return get_frames(self.path)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>All scenes inside one directory have a unique id.
The id of a new Scene is always 1 + previously largest id.</p>
<p>For a single scene, <code>type(id) = int</code>, for a batch, <code>type(id) = tuple</code>.</p></div>
</dd>
<dt id="phi.app.Scene.parent_directory"><code class="name">var <span class="ident">parent_directory</span></code></dt>
<dd>
<div class="desc"><p>Directory containing the scene directory.</p></div>
</dd>
<dt id="phi.app.Scene.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"><p>Relative path of the scene directory.</p>
<p>For a single scene, <code>type(path) = str</code>, for a batch, <code>type(path) = tuple</code>.</p></div>
</dd>
<dt id="phi.app.Scene.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    self._init_properties()
    return self._properties</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.app.Scene.copy_calling_script"><code class="name flex">
<span>def <span class="ident">copy_calling_script</span></span>(<span>self, full_trace=False, include_context_information=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the Python file that called this method into the <code>src</code> folder of this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>full_trace</code></strong></dt>
<dd>Whether to include scripts that indirectly called this method.</dd>
<dt><strong><code>include_context_information</code></strong></dt>
<dd>If True, writes the phiflow version and <code>sys.argv</code> into <code>context.json</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_calling_script(self, full_trace=False, include_context_information=True):
    &#34;&#34;&#34;
    Copies the Python file that called this method into the `src` folder of this `Scene`.

    Args:
        full_trace: Whether to include scripts that indirectly called this method.
        include_context_information: If True, writes the phiflow version and `sys.argv` into `context.json`.
    &#34;&#34;&#34;
    script_paths = [frame[1] for frame in inspect.stack()]
    script_paths = list(filter(lambda path: not _is_phi_file(path), script_paths))
    script_paths = set(script_paths) if full_trace else [script_paths[0]]
    for script_path in script_paths:
        shutil.copy(script_path, join(self.subpath(&#39;src&#39;, create=True), basename(script_path)))
    if include_context_information:
        with open(join(self.subpath(&#39;src&#39;, create=True), &#39;context.json&#39;), &#39;w&#39;) as context_file:
            json.dump({
                &#39;phi_version&#39;: phi_version,
                &#39;argv&#39;: sys.argv
            }, context_file)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.copy_src"><code class="name flex">
<span>def <span class="ident">copy_src</span></span>(<span>self, path, only_external=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_src(self, path, only_external=True):
    if not only_external or not _is_phi_file(path):
        shutil.copy(path, join(self.subpath(&#39;src&#39;, create=True), basename(path)))</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.data_paths"><code class="name flex">
<span>def <span class="ident">data_paths</span></span>(<span>self, frames, field_names)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_paths(self, frames, field_names):
    for frame in frames:
        yield tuple([_filename(self.path, name, frame) for name in field_names])</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.exists_config"><code class="name flex">
<span>def <span class="ident">exists_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the configuration file <em>description.json</em> exists. In batch mode, tests if any configuration exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists_config(self):
    &#34;&#34;&#34; Tests if the configuration file *description.json* exists. In batch mode, tests if any configuration exists. &#34;&#34;&#34;
    if isinstance(self.path, str):
        return isfile(join(self.path, &#34;description.json&#34;))
    else:
        return any(isfile(join(p, &#34;description.json&#34;)) for p in self.path)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.get_frames"><code class="name flex">
<span>def <span class="ident">get_frames</span></span>(<span>self, mode='intersect')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frames(self, mode=&#34;intersect&#34;):
    return get_frames(self.path, None, mode)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>self, subdir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir(self, subdir=None):
    assert isinstance(self.path, str)
    isdir(self.path) or os.mkdir(self.path)
    if subdir is not None:
        subpath = join(self.path, subdir)
        isdir(subpath) or os.mkdir(subpath)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.put_property"><code class="name flex">
<span>def <span class="ident">put_property</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_property(self, key, value):
    self._init_properties()
    self._properties[key] = value
    with open(join(self.path, &#34;description.json&#34;), &#34;w&#34;) as out:
        json.dump(self._properties, out, indent=2)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, names: str, frame=0, convert_to_backend=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads one or multiple fields from disc.</p>
<p>See Also:
<code><a title="phi.app.Scene.write" href="#phi.app.Scene.write">Scene.write()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong></dt>
<dd>Single field name or sequence of field names.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
<dt><strong><code>convert_to_backend</code></strong></dt>
<dd>Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Single <code><a title="phi.field.Field" href="../field/index.html#phi.field.Field">Field</a></code> or sequence of fields, depending on the type of <code>names</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, names: str or tuple or list, frame=0, convert_to_backend=True):
    &#34;&#34;&#34;
    Reads one or multiple fields from disc.

    See Also:
        `Scene.write()`.

    Args:
        names: Single field name or sequence of field names.
        frame: Frame number.
        convert_to_backend: Whether to convert the read data to the data format of the default backend, e.g. TensorFlow tensors.

    Returns:
        Single `phi.field.Field` or sequence of fields, depending on the type of `names`.
    &#34;&#34;&#34;
    return read_sim_frame(self.path, names, frame=frame, convert_to_backend=convert_to_backend, batch_dim=self.batch_dim)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.read_array"><code class="name flex">
<span>def <span class="ident">read_array</span></span>(<span>self, field_name, frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_array(self, field_name, frame):
    return read_sim_frame(self.path, field_name, frame=frame, batch_dim=self.batch_dim)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the scene directory and all contained files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self):
    &#34;&#34;&#34; Deletes the scene directory and all contained files. &#34;&#34;&#34;
    if isinstance(self.abs_path, str):
        if isdir(self.abs_path):
            shutil.rmtree(self.abs_path)
    else:
        for p in self.abs_path:
            if isdir(p):
                shutil.rmtree(p)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.subpath"><code class="name flex">
<span>def <span class="ident">subpath</span></span>(<span>self, name: str, create: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the relative path <code>name</code> with this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> as the root folder.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Relative path with this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code> as the root folder.</dd>
<dt><strong><code>create</code></strong></dt>
<dd>Whether to create a directory of that name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Relative path including the path to this <code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code>.
In batch mode, returns a <code>tuple</code>, else a <code>str</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subpath(self, name: str, create: bool = False) -&gt; str or tuple:
    &#34;&#34;&#34;
    Resolves the relative path `name` with this `Scene` as the root folder.

    Args:
        name: Relative path with this `Scene` as the root folder.
        create: Whether to create a directory of that name.

    Returns:
        Relative path including the path to this `Scene`.
        In batch mode, returns a `tuple`, else a `str`.
    &#34;&#34;&#34;
    if isinstance(self.path, str):
        path = join(self.path, name)
        if create and not isdir(path):
            os.mkdir(path)
        return path
    else:
        result = []
        for p in self.path:
            path = join(p, name)
            if create and not isdir(path):
                os.mkdir(path)
            result.append(path)
        return tuple(result)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data: dict, frame=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes fields to this scene.
One NumPy file will be created for each <code><a title="phi.field.Field" href="../field/index.html#phi.field.Field">Field</a></code></p>
<p>See Also:
<code><a title="phi.app.Scene.read" href="#phi.app.Scene.read">Scene.read()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd><code>dict</code> mapping field names to <code>Field</code> objects that can be written using <code><a title="phi.field.write" href="../field/index.html#phi.field.write">write()</a></code>.</dd>
<dt><strong><code>frame</code></strong></dt>
<dd>Frame number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data: dict, frame=0):
    &#34;&#34;&#34;
    Writes fields to this scene.
    One NumPy file will be created for each `phi.field.Field`

    See Also:
        `Scene.read()`.

    Args:
        data: `dict` mapping field names to `Field` objects that can be written using `phi.field.write()`.
        frame: Frame number.
    &#34;&#34;&#34;
    write_sim_frame(self.path, data, names=None, frame=frame, batch_dim=self.batch_dim)</code></pre>
</details>
</dd>
<dt id="phi.app.Scene.write_sim_frame"><code class="name flex">
<span>def <span class="ident">write_sim_frame</span></span>(<span>self, arrays, fieldnames, frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_sim_frame(self, arrays, fieldnames, frame):
    write_sim_frame(self.path, arrays, names=fieldnames, frame=frame, batch_dim=self.batch_dim)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.app.show" href="#phi.app.show">show</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.app.App" href="#phi.app.App">App</a></code></h4>
<ul class="">
<li><code><a title="phi.app.App.actions" href="#phi.app.App.actions">actions</a></code></li>
<li><code><a title="phi.app.App.add_action" href="#phi.app.App.add_action">add_action</a></code></li>
<li><code><a title="phi.app.App.add_custom_properties" href="#phi.app.App.add_custom_properties">add_custom_properties</a></code></li>
<li><code><a title="phi.app.App.add_custom_property" href="#phi.app.App.add_custom_property">add_custom_property</a></code></li>
<li><code><a title="phi.app.App.add_field" href="#phi.app.App.add_field">add_field</a></code></li>
<li><code><a title="phi.app.App.add_trait" href="#phi.app.App.add_trait">add_trait</a></code></li>
<li><code><a title="phi.app.App.benchmark" href="#phi.app.App.benchmark">benchmark</a></code></li>
<li><code><a title="phi.app.App.controls" href="#phi.app.App.controls">controls</a></code></li>
<li><code><a title="phi.app.App.custom_properties" href="#phi.app.App.custom_properties">custom_properties</a></code></li>
<li><code><a title="phi.app.App.debug" href="#phi.app.App.debug">debug</a></code></li>
<li><code><a title="phi.app.App.directory" href="#phi.app.App.directory">directory</a></code></li>
<li><code><a title="phi.app.App.dt" href="#phi.app.App.dt">dt</a></code></li>
<li><code><a title="phi.app.App.fieldnames" href="#phi.app.App.fieldnames">fieldnames</a></code></li>
<li><code><a title="phi.app.App.format_time" href="#phi.app.App.format_time">format_time</a></code></li>
<li><code><a title="phi.app.App.frame" href="#phi.app.App.frame">frame</a></code></li>
<li><code><a title="phi.app.App.framerate" href="#phi.app.App.framerate">framerate</a></code></li>
<li><code><a title="phi.app.App.get_field" href="#phi.app.App.get_field">get_field</a></code></li>
<li><code><a title="phi.app.App.info" href="#phi.app.App.info">info</a></code></li>
<li><code><a title="phi.app.App.invalidate" href="#phi.app.App.invalidate">invalidate</a></code></li>
<li><code><a title="phi.app.App.name" href="#phi.app.App.name">name</a></code></li>
<li><code><a title="phi.app.App.new_scene" href="#phi.app.App.new_scene">new_scene</a></code></li>
<li><code><a title="phi.app.App.pause" href="#phi.app.App.pause">pause</a></code></li>
<li><code><a title="phi.app.App.play" href="#phi.app.App.play">play</a></code></li>
<li><code><a title="phi.app.App.prepare" href="#phi.app.App.prepare">prepare</a></code></li>
<li><code><a title="phi.app.App.prepared" href="#phi.app.App.prepared">prepared</a></code></li>
<li><code><a title="phi.app.App.run_action" href="#phi.app.App.run_action">run_action</a></code></li>
<li><code><a title="phi.app.App.run_step" href="#phi.app.App.run_step">run_step</a></code></li>
<li><code><a title="phi.app.App.running" href="#phi.app.App.running">running</a></code></li>
<li><code><a title="phi.app.App.scene_summary" href="#phi.app.App.scene_summary">scene_summary</a></code></li>
<li><code><a title="phi.app.App.set_state" href="#phi.app.App.set_state">set_state</a></code></li>
<li><code><a title="phi.app.App.settings_str" href="#phi.app.App.settings_str">settings_str</a></code></li>
<li><code><a title="phi.app.App.show" href="#phi.app.App.show">show</a></code></li>
<li><code><a title="phi.app.App.start_time" href="#phi.app.App.start_time">start_time</a></code></li>
<li><code><a title="phi.app.App.status" href="#phi.app.App.status">status</a></code></li>
<li><code><a title="phi.app.App.step" href="#phi.app.App.step">step</a></code></li>
<li><code><a title="phi.app.App.steps" href="#phi.app.App.steps">steps</a></code></li>
<li><code><a title="phi.app.App.subtitle" href="#phi.app.App.subtitle">subtitle</a></code></li>
<li><code><a title="phi.app.App.summary" href="#phi.app.App.summary">summary</a></code></li>
<li><code><a title="phi.app.App.time" href="#phi.app.App.time">time</a></code></li>
<li><code><a title="phi.app.App.traits" href="#phi.app.App.traits">traits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableBool" href="#phi.app.EditableBool">EditableBool</a></code></h4>
</li>
<li>
<h4><code><a title="phi.app.EditableFloat" href="#phi.app.EditableFloat">EditableFloat</a></code></h4>
<ul class="">
<li><code><a title="phi.app.EditableFloat.use_log_scale" href="#phi.app.EditableFloat.use_log_scale">use_log_scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableInt" href="#phi.app.EditableInt">EditableInt</a></code></h4>
</li>
<li>
<h4><code><a title="phi.app.EditableString" href="#phi.app.EditableString">EditableString</a></code></h4>
<ul class="">
<li><code><a title="phi.app.EditableString.rows" href="#phi.app.EditableString.rows">rows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.EditableValue" href="#phi.app.EditableValue">EditableValue</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.app.EditableValue.category" href="#phi.app.EditableValue.category">category</a></code></li>
<li><code><a title="phi.app.EditableValue.initial_value" href="#phi.app.EditableValue.initial_value">initial_value</a></code></li>
<li><code><a title="phi.app.EditableValue.is_linear" href="#phi.app.EditableValue.is_linear">is_linear</a></code></li>
<li><code><a title="phi.app.EditableValue.max_value" href="#phi.app.EditableValue.max_value">max_value</a></code></li>
<li><code><a title="phi.app.EditableValue.min_value" href="#phi.app.EditableValue.min_value">min_value</a></code></li>
<li><code><a title="phi.app.EditableValue.name" href="#phi.app.EditableValue.name">name</a></code></li>
<li><code><a title="phi.app.EditableValue.type" href="#phi.app.EditableValue.type">type</a></code></li>
<li><code><a title="phi.app.EditableValue.value" href="#phi.app.EditableValue.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.ModuleViewer" href="#phi.app.ModuleViewer">ModuleViewer</a></code></h4>
<ul class="">
<li><code><a title="phi.app.ModuleViewer.range" href="#phi.app.ModuleViewer.range">range</a></code></li>
<li><code><a title="phi.app.ModuleViewer.step" href="#phi.app.ModuleViewer.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.app.Scene" href="#phi.app.Scene">Scene</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.app.Scene.at" href="#phi.app.Scene.at">at</a></code></li>
<li><code><a title="phi.app.Scene.copy_calling_script" href="#phi.app.Scene.copy_calling_script">copy_calling_script</a></code></li>
<li><code><a title="phi.app.Scene.copy_src" href="#phi.app.Scene.copy_src">copy_src</a></code></li>
<li><code><a title="phi.app.Scene.create" href="#phi.app.Scene.create">create</a></code></li>
<li><code><a title="phi.app.Scene.data_paths" href="#phi.app.Scene.data_paths">data_paths</a></code></li>
<li><code><a title="phi.app.Scene.exists_config" href="#phi.app.Scene.exists_config">exists_config</a></code></li>
<li><code><a title="phi.app.Scene.fieldnames" href="#phi.app.Scene.fieldnames">fieldnames</a></code></li>
<li><code><a title="phi.app.Scene.frames" href="#phi.app.Scene.frames">frames</a></code></li>
<li><code><a title="phi.app.Scene.get_frames" href="#phi.app.Scene.get_frames">get_frames</a></code></li>
<li><code><a title="phi.app.Scene.id" href="#phi.app.Scene.id">id</a></code></li>
<li><code><a title="phi.app.Scene.list" href="#phi.app.Scene.list">list</a></code></li>
<li><code><a title="phi.app.Scene.mkdir" href="#phi.app.Scene.mkdir">mkdir</a></code></li>
<li><code><a title="phi.app.Scene.parent_directory" href="#phi.app.Scene.parent_directory">parent_directory</a></code></li>
<li><code><a title="phi.app.Scene.path" href="#phi.app.Scene.path">path</a></code></li>
<li><code><a title="phi.app.Scene.properties" href="#phi.app.Scene.properties">properties</a></code></li>
<li><code><a title="phi.app.Scene.put_property" href="#phi.app.Scene.put_property">put_property</a></code></li>
<li><code><a title="phi.app.Scene.read" href="#phi.app.Scene.read">read</a></code></li>
<li><code><a title="phi.app.Scene.read_array" href="#phi.app.Scene.read_array">read_array</a></code></li>
<li><code><a title="phi.app.Scene.remove" href="#phi.app.Scene.remove">remove</a></code></li>
<li><code><a title="phi.app.Scene.subpath" href="#phi.app.Scene.subpath">subpath</a></code></li>
<li><code><a title="phi.app.Scene.write" href="#phi.app.Scene.write">write</a></code></li>
<li><code><a title="phi.app.Scene.write_sim_frame" href="#phi.app.Scene.write_sim_frame">write_sim_frame</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>